## Regular Expression

前言：Shift+Command+V 可以 preview markdown

#### 分枝条件

正则表达式里的 **分枝条件** 指的是有几种规则，如果满足其中任意一种规则，都应该当成匹配，具体方法是用 `|` 把不同的规则分隔开。

```
0\d{2}-\d{8}|0\d{3}-\d{7} // 匹配两种以连字号分隔的电话号码，一种是三位区号，8位本地号（如 010-12345678），一种是4位区号，7位本地号（0376-6631110）
```

**使用分枝条件时，要注意各个条件的顺序**：从左到右，前面的条件不能是后面的条件的子集，否则后面的条件将无法被匹配到。

#### 分组

用 *小括号* 来指定 **子表达式** 也叫做 **分组**

例子：

```
(\d{1,3}\.){3}\d{1,3} // 匹配 www.xxx.yyy.zzz 的格式
((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?) // IP 地址
```

#### 反义

代码/语法|说明
---|---|
\W|匹配任意不是字母，数字，下划线，汉字的字符
\S|匹配任意不是空白符的字符
\D|匹配任意非数字的字符
\B|匹配不是单词开头或结束的位置
[^x]|匹配除了x以外的任意字符
[^aeiou]|匹配除了aeiou这几个字母外的任意字符

#### 后向引用

默认情况下，每个分组会自动拥有一个 **组号**，从左到右，第一个组号为1，第二个为2，以此类推。

**后向引用** 用于重复搜索前面某个分组匹配的文本。例子：

```
\b(\w+)\b\s+\1\b // 匹配重复单词 如 go go 或者 kitty kitty
```

也可以自己制定分组的 **组名**: `(?<Word>\w+)` 或者 `(?'Word'\w+)` 这样就把 \w+ 的组名指定为 `Word` 了，要引用这个分组 **捕获的内容** 可以用 `\k<Word>`，所以上面的例子可以写成：

```
\b(?<Word>\w+)\b\s+\k<Word>\b // 采用自定义组名的方式匹配重复单词
```

#### 零宽断言

P.S: 这个英文怎么说来着???

**零宽断言** 的特点：

* 查找某些内容之前/后的东西，但不包括这些内容
* 像 `\b, ^, $` 那样用于指定一个位置，应该满足一定的条件（即断言）

例子：

`(?=exp)` - **零宽度正预测先行断言**，如：`\b\w+(?=ing\b)` 匹配 __以ing结尾的单词的前面部分（除了ing的部分）__

用该表达式查找 *I'm singing while you're dancing.* 时会匹配 _sing_ 和 _danc_

`(?<=exp)` - **零宽度正回顾后发断言**，如：`(?<=\bre)\w+\b` 匹配 __以re开头的单词的后半部分（除了re以外的部分）__

用该表达式查找 *reading a book* 时，他匹配 _ading_

最后一个例子：`(?<=\s)\d+(?=\s)` 匹配 __以空白符间隔的数字（不包括空白符）__

#### 负向零宽断言

和 **零宽断言** 类似，只是断言该位置后面 **不能** 匹配表达式 exp

（妈的好拗口啊）
[Negative Lookahead] - 零宽度负预测先行断言
[Negative Lookbehind] - 零宽度负回顾后发断言

例子：

* `\d{3}(?!\d)` - __匹配三位数字，且三位数字的后面不能是数字__
* `(?<![a-z])\d{7}` - 匹配 __前面不是小写字母的7位数__
* `(?<=<(\w+)>).*(?=<\/\1>)` - Guess what?

#### 注释

`(?#comment)` 包含注释

#### Greedy & Lazy

当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符。称为 **贪婪** 匹配

在限定符后面加 `?` 可以转化为懒惰匹配模式。 例子：

```
a.*b // 匹配 aabab
a.*?b // 匹配 aab 和 ab
```

#### 处理选项

* Multiline(多行模式) - 更改 `^` 和 `$` 的含义，使它们分别在任意一行的行首和行尾匹配，而不仅仅在整个字符串的开头和结尾匹配。

#### 平衡组/递归匹配

不多说了 上例子

```
<                         #最外层的左括号
    [^<>]*                #最外层的左括号后面的不是括号的内容
    (
        (
            (?'Open'<)    #碰到了左括号，在黑板上写一个"Open"
            [^<>]*        #匹配左括号后面的不是括号的内容
        )+
        (
            (?'-Open'>)   #碰到了右括号，擦掉一个"Open"
            [^<>]*        #匹配右括号后面不是括号的内容
        )+
    )*
    (?(Open)(?!))         #在遇到最外层的右括号前面，判断黑板上还有没有没擦掉的"Open"；如果还有，则匹配失败

>                         #最外层的右括号
```

#### (补充)零宽断言

tl;dr

使用零宽断言, 避免匹配过程中因为断言消耗了字符而使得下一次匹配的起始位置向后挪，而丢掉某些匹配。

### Reference

[正则表达式30分钟入门教程](http://deerchao.net/tutorials/regex/regex.htm)
[正则表达式之：零宽断言不『消费』](http://fxck.it/post/50558232873)